

//keywords

resistor
voltageSource
ground
currentSource
capacitor
inductor
line
output
structure
current
voltage

ID [A-Za-z_][A-Za-z0-9_]*

floatConstant ([0-9]+{.[0-9]*}|.[0-9]+){[eE][+-]?[0-9]+}

stringConstant ".*"

constant (i?)([0-9]+{.[0-9]*}|.[0-9]+){[eE][+-]?[0-9]+}| ".*"

complex constant: iconstant

model: statement model | eps

statement: expression;

expression: expression + expression
	| expression - expression
	| expression = epxression
	| expression * expression
	| expression /expression
	| id 
	| const
	| id (functionArguments)

functionArguments: expression functionArguments'

functionArguments': , functionArguments


circuitDescription -> circuitStructure output
circuitStructure -> 'structure:'cS'
cS' -> structureExpression ';' cS' | eps
structureExpression -> id = structureExpression
structureExpression -> id( functionArguments )
functionArguments -> eps | const functionArguments'
functionArguments' ->  eps | , const functionArguments'
output -> 'output:' outputStatements
outputStatements -> id(outputArguments) ; outputStatements | eps 
outputArguments -> (id | const) outputArguments'
outputArgument' -> , (id | const) outputArguments'


value=5.6+4.3;
/*Possible format:*/
element=resistor(value,nodeLabel1,nodeLabel2);
element=voltageSource(value,nodeLabel1,nodeLabel2);
element=ground(nodeLabel);
element=capacitor(value,nodeLabel1,nodeLabel2);
element=inductor(value,nodeLabel1,nodeLabel2);
element=currentSource(value,nodeLabel1,nodeLabel2);
element=line(nodeLabel1,nodeLabel2); /*- zero resistance*/
/*output*/
current(element);
voltage(element);/* - voltage drop on element*/
voltage(node);/* - relative voltage on node*/
voltage(node1,node2);/* - (phi2-phi1)*/






/*
	model: (state = modelStatement)*;
	
	modelStatement:  statement #ModelStatementRule
					| classDefinition #ClassDefinitionRule
					| functionDefinition #functionDefinitionRule
					;

	classDefinition: CLASS className=id classInheritance LCRLPAREN classDefinitionBody RCRLPAREN ;
	classInheritance: COLON className=id 
					| 
					;
	classDefinitionBody: (stat=classDefintionStatement)* ;
	classDefinitionStatement: fieldDefinition #FieldDefinitionRule
			| methodDefinition #MethodDefinitionRule
			| access=(PUBLIC|PRIVATE|PROTECTED) COLON #AccessRule
			;
	methodDefinition: functionDefinition #FunctionRule
					| constructorDefinition #ConstructorRule
					;
	constructorDefinition: CONSTRUCTOR LPAREN functionArgsDefinition RPAREN;
	fieldDefinition: fieldModificator typeName=id fieldName=id SEMICOLON;
	fieldModificator: (STATIC|CONST)*;

	functionDefinition: FUNCTION functionName=id LPAREN functionArgsDefinition RPAREN LCRLPAREN (state=statement)* RCRLPAREN ;
	functionArgsDefinition: functionArgDefinition (COMMA functionArgDefinition)* | ;
	functionArgDefinition: typeName=id argName=id ;

	CONSTRUCTOR:"constructor";
	FUNCTION:"function";
	PUBLIC:"public";
	PRIVATE:"private";
	PROTECTED:"protected";
	CLASS:"class";
	STATIC:"static";
	CONST:"const";

*/



/*fragment A : [aA]; 
fragment B : [bB];
fragment C : [cC];
fragment D : [dD];
fragment E : [eE];
fragment F : [fF];
fragment G : [gG];
fragment H : [hH];
fragment I : [iI];
fragment J : [jJ];
fragment K : [kK];
fragment L : [lL];
fragment M : [mM];
fragment N : [nN];
fragment O : [oO];
fragment P : [pP];
fragment Q : [qQ];
fragment R : [rR];
fragment S : [sS];
fragment T : [tT];
fragment U : [uU];
fragment V : [vV];*/


/*RESISTOR			:RESISTOR;
VOLTAGESOURCE		:VOLTAGESOURCE;
VOLTAGE				:VOLTAGE;
CURRENT				:CURRENT;
LINE				:LINE;
CURRENTSOURCE		:CURRENTSOURCE;
CAPACITOR			:CAPACITOR;
GROUND				:GROUND;*/






compileUnit = (statement)*;

statement = expression SEMICOLON|
SEMICOLON;

expression = expression ASSIGN expression |
 expression + expression |
 epxression - expression |
 ...
 ID{ ObjectArguments} |
 expression[expression];

 ObjectArguments = Argument (COMMA Argument)* | ;

 Argument = ID ASSIGN expression;

ref=Transformer
{
	Key=Value,
	Key2=Value2
};

ref=Load
{
	type=Type,

};

